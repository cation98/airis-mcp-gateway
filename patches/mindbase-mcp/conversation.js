/**
 * MindBase MCP Server - Conversation Tools
 *
 * Tool implementations for conversation management
 */
export class ConversationTools {
    storage;
    currentSessionId;
    constructor(storage) {
        this.storage = storage;
    }
    /**
     * Set current session ID for context
     */
    setCurrentSession(sessionId) {
        this.currentSessionId = sessionId;
    }
    /**
     * conversation_save - Save conversation with automatic embedding
     */
    async conversationSave(args) {
        const item = {
            id: '', // Will be generated by storage
            sessionId: args.sessionId || this.currentSessionId,
            source: args.source,
            title: args.title,
            content: args.content,
            metadata: args.metadata || {},
            category: args.category,
            priority: args.priority,
            channel: args.channel,
            createdAt: new Date(),
            updatedAt: new Date(),
        };
        const id = await this.storage.save(item);
        return {
            id,
            createdAt: item.createdAt.toISOString(),
        };
    }
    /**
     * conversation_get - Retrieve conversations with filtering
     */
    async conversationGet(args) {
        // If ID is provided, get single item
        if (args.id) {
            const item = await this.storage.getById(args.id);
            if (!item) {
                return { items: [], total: 0, hasMore: false };
            }
            return {
                items: [this.formatItem(item)],
                total: 1,
                hasMore: false,
            };
        }
        // Otherwise, get with filters
        const filters = {
            source: args.source,
            category: args.category,
            priority: args.priority,
            channel: args.channel,
            sessionId: args.sessionId || this.currentSessionId,
            limit: args.limit || 100,
            offset: args.offset || 0,
            createdAfter: args.createdAfter ? new Date(args.createdAfter) : undefined,
            createdBefore: args.createdBefore ? new Date(args.createdBefore) : undefined,
        };
        // Get items and count in parallel
        const { limit, offset, ...countFilters } = filters;
        const [items, total] = await Promise.all([
            this.storage.get(filters),
            this.storage.count(countFilters),
        ]);
        const hasMore = (offset || 0) + items.length < total;
        return {
            items: items.map(this.formatItem),
            total,
            hasMore,
        };
    }
    /**
     * conversation_search - Semantic search across conversations
     */
    async conversationSearch(args) {
        const threshold = args.threshold ?? 0.5;
        const limit = args.limit ?? 10;
        const results = await this.storage.semanticSearch(args.query, limit, threshold);
        // Filter by source if specified
        let filteredResults = results;
        if (args.source) {
            filteredResults = results.filter((r) => r.item.source === args.source);
        }
        return {
            items: filteredResults.map((result) => ({
                ...this.formatItem(result.item),
                similarity: result.similarity,
                semanticScore: result.semanticScore,
            })),
            query: args.query,
        };
    }
    /**
     * conversation_hybrid_search - Hybrid search combining keyword and semantic search
     */
    async conversationHybridSearch(args) {
        const options = {
            keywordWeight: args.keywordWeight ?? 0.3,
            semanticWeight: args.semanticWeight ?? 0.7,
            threshold: args.threshold ?? 0.6,
            limit: args.limit ?? 10,
        };
        const results = await this.storage.hybridSearch(args.query, options);
        // Filter by source if specified
        let filteredResults = results;
        if (args.source) {
            filteredResults = results.filter((r) => r.item.source === args.source);
        }
        return {
            items: filteredResults.map((result) => ({
                ...this.formatItem(result.item),
                keywordScore: result.keywordScore,
                semanticScore: result.semanticScore,
                combinedScore: result.combinedScore,
            })),
            query: args.query,
            weights: {
                keyword: options.keywordWeight,
                semantic: options.semanticWeight,
            },
        };
    }
    /**
     * conversation_delete - Delete conversation by ID
     */
    async conversationDelete(args) {
        const success = await this.storage.delete(args.id);
        return {
            success,
            deletedId: success ? args.id : undefined,
        };
    }
    /**
     * session_create - Create new session
     */
    async sessionCreate(args) {
        const id = await this.storage.createSession(args.name, args.description, args.parentId);
        const session = await this.storage.getSession(id);
        if (!session) {
            throw new Error('Failed to retrieve created session');
        }
        return {
            id: session.id,
            name: session.name,
            createdAt: session.createdAt.toISOString(),
        };
    }
    /**
     * session_start - Start or resume a session
     */
    async sessionStart(args) {
        let sessionId = args.sessionId;
        // If no sessionId provided, create new session
        if (!sessionId && args.name) {
            sessionId = await this.storage.createSession(args.name, args.description);
        }
        if (!sessionId) {
            throw new Error('Either sessionId or name must be provided');
        }
        const session = await this.storage.getSession(sessionId);
        if (!session) {
            throw new Error(`Session not found: ${sessionId}`);
        }
        // Set as current session
        this.currentSessionId = session.id;
        return {
            id: session.id,
            name: session.name,
            description: session.description,
            itemCount: session.itemCount || 0,
            createdAt: session.createdAt.toISOString(),
        };
    }
    /**
     * session_list - List recent sessions
     */
    async sessionList(args) {
        const limit = args?.limit || 10;
        const sessions = await this.storage.listSessions(limit);
        return {
            sessions: sessions.map((s) => ({
                id: s.id,
                name: s.name,
                description: s.description,
                parentId: s.parentId,
                itemCount: s.itemCount || 0,
                createdAt: s.createdAt.toISOString(),
                updatedAt: s.updatedAt.toISOString(),
            })),
            total: sessions.length,
        };
    }
    /**
     * session_delete - Delete a session
     */
    async sessionDelete(args) {
        const success = await this.storage.deleteSession(args.id);
        // If deleted session was current, clear it
        if (success && this.currentSessionId === args.id) {
            this.currentSessionId = undefined;
        }
        return {
            success,
            deletedId: success ? args.id : undefined,
        };
    }
    /**
     * Format conversation item for output
     */
    formatItem(item) {
        return {
            id: item.id,
            sessionId: item.sessionId,
            source: item.source,
            title: item.title,
            content: item.content,
            metadata: item.metadata,
            category: item.category,
            priority: item.priority,
            channel: item.channel,
            createdAt: item.createdAt.toISOString(),
            updatedAt: item.updatedAt.toISOString(),
        };
    }
}
//# sourceMappingURL=conversation.js.map